{"dependencies":[{"name":"./property","loc":{"line":1,"column":23}},{"name":"type","loc":{"line":5,"column":19}},{"name":"dot","loc":{"line":6,"column":16}},{"name":"component-type","loc":{"line":8,"column":19}},{"name":"eivindfjeldstad-dot","loc":{"line":9,"column":16}}],"generated":{"js":"var Property = require('./property');\nvar typeOf, dot;\n\ntry {\n  typeOf = require('type');\n  dot = require('dot');\n} catch (err) {\n  typeOf = require('component-type');\n  dot = require('eivindfjeldstad-dot');\n}\n\n/**\n * Expose schema\n */\n\nmodule.exports = Schema;\n\n/**\n * Schema constructor\n *\n * @param {Object} [obj]\n * @param {Object} [opts]\n * @api public\n */\n\nfunction Schema (obj, opts) {\n  if (!(this instanceof Schema)) return new Schema(obj, opts);\n  obj = obj || {};\n  this.props = {};\n  this.opts = opts || {};\n  for (var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n    this.path(key, obj[key]);\n  }\n}\n\n/**\n * Add given `path` to schema with optional `rules`\n *\n * @param {String} path\n * @param {Object} [rules]\n * @return {Property}\n * @api public\n */\n\nSchema.prototype.path = function (path, rules) {\n  var nested = false;\n  var prop = this.props[path] || new Property(path, this);\n  this.props[path] = prop;\n\n  // no rules?\n  if (!rules) return prop;\n\n  // check if nested\n  for (var key in rules) {\n    if (!rules.hasOwnProperty(key)) continue;\n    if ('function' == typeof prop[key]) continue;\n    nested = true;\n    break;\n  }\n\n  for (var key in rules) {\n    if (!rules.hasOwnProperty(key)) continue;\n\n    if (nested) {\n      this.path(join(key, path), rules[key]);\n      continue;\n    }\n\n    var rule = rules[key];\n    if (!Array.isArray(rule)) rule = [rule];\n    prop[key].apply(prop, rule);\n  }\n\n  return prop;\n};\n\n/**\n * Typecast given `obj`\n *\n * @param {Object} obj\n * @api public\n */\n\nSchema.prototype.typecast = function (obj) {\n  for (var key in this.props) {\n    var prop = this.props[key];\n    var value = dot.get(obj, key);\n    if (value == null) continue;\n    dot.set(obj, key, prop.typecast(value));\n  }\n};\n\n/**\n * Strip all keys not in the schema\n *\n * @param {Object} obj\n * @param {String} [prefix]\n * @api public\n */\n\nSchema.prototype.strip = function (obj, prefix) {\n  for (var key in obj) {\n    var path = join(key, prefix);\n\n    if (!obj.hasOwnProperty(key)) continue;\n\n    if (!this.props[path]) {\n      delete obj[key];\n      continue;\n    }\n\n    if (typeOf(obj[key]) == 'object') {\n      this.strip(obj[key], path);\n    }\n  }\n};\n\n/**\n * Validate given `obj`\n *\n * @param {Object} obj\n * @param {Object} [opts]\n * @return {Array}\n * @api public\n */\n\nSchema.prototype.validate = function (obj, opts) {\n  var errors = [];\n  opts = opts || this.opts;\n\n  if (opts.typecast) this.typecast(obj);\n  if (opts.strip !== false) this.strip(obj);\n\n  for (var key in this.props) {\n    var prop = this.props[key];\n    var value = dot.get(obj, key);\n    var err = prop.validate(value, obj);\n    if (err) errors.push(err);\n  }\n\n  return errors;\n};\n\n/**\n * Assert that given `obj` is valid\n *\n * @param {Object} obj\n * @param {Object} [opts]\n * @api public\n */\n\nSchema.prototype.assert = function (obj, opts) {\n  var errors = this.validate(obj, opts);\n  if (errors.length > 0) throw errors[0];\n};\n\n/**\n * Join `path` with `prefix`\n */\n\nfunction join (path, prefix) {\n  return prefix\n    ? prefix + '.' + path\n    : path;\n}\n"},"hash":"e70bf1c5677c7b4db8e6a0a2a73a2bd6"}